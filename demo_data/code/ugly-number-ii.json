[
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5653377/no-dp-easy-min-heap-beginner-friendly-by-m271/",
    "content": "Intuition\n\nConverted the DFS of multipying 1 with 2,3 and 5 and then again with the same.\nApproach\n\nWe start with 1 and then keep multiplying the numbers with 2, 3 and 5\n1\n├── 2\n│   ├── 4\n│   │   ├── 8\n│   │   ├── 12\n│   │   └── 20\n│   ├── 6\n│   │   ├── 12\n│   │   ├── 18\n│   │   └── 30\n│   └── 10\n│       ├── 20\n│       ├── 30\n│       └── 50\n├── 3\n│   ├── 6\n│   │   ├── 12\n│   │   ├── 18\n│   │   └── 30\n│   ├── 9\n│   │   ├── 18\n│   │   ├── 27\n│   │   └── 45\n│   └── 15\n│       ├── 30\n│       ├── 45\n│       └── 75\n└── 5\n    ├── 10\n    │   ├── 20\n    │   ├── 30\n    │   └── 50\n    ├── 15\n    │   ├── 30\n    │   ├── 45\n    │   └── 75\n    └── 25\n        ├── 50\n        ├── 75\n        └── 125\n\nand for every iteration pick up the smallest element.\nBut, how do we get the smallest element, in every iteration,\nIs there any Data Structure which always gives the smallest element.\nOhh yes there is and its called Min-Heap.\nComplexity\n\nTime complexity:\n\n\nO(n∗logn)\n\nSpace complexity:\n\n\nO(n)\nCode\nclass Solution\n{\npublic:\n    typedef long long ll;\n\n    int nthUglyNumber(int n)\n    {\n        // Create a min Heap\n        priority_queue<ll, vector<ll>, greater<ll>> pq;\n        // Set to check so that we do not add the same number twice\n        unordered_set<ll> vis;\n\n        pq.push(1);\n        vis.insert(1);\n\n        ll val = 1;\n\n        while (n > 0)\n        {\n            //Take the top element\n            val = pq.top();\n            pq.pop();\n            n--; \n\n            if (vis.find(val * 2) == vis.end())\n            {\n                pq.push(val * 2);\n                vis.insert(val * 2);\n            }\n            if (vis.find(val * 3) == vis.end())\n            {\n                pq.push(val * 3);\n                vis.insert(val * 3);\n            }\n            if (vis.find(val * 5) == vis.end())\n            {\n                pq.push(val * 5);\n                vis.insert(val * 5);\n            }\n        }\n\n        return val; // After n iterations this is the number you get\n    }\n};",
    "code_blocks": [
      "class Solution\n{\npublic:\n    typedef long long ll;\n\n    int nthUglyNumber(int n)\n    {\n        // Create a min Heap\n        priority_queue<ll, vector<ll>, greater<ll>> pq;\n        // Set to check so that we do not add the same number twice\n        unordered_set<ll> vis;\n\n        pq.push(1);\n        vis.insert(1);\n\n        ll val = 1;\n\n        while (n > 0)\n        {\n            //Take the top element\n            val = pq.top();\n            pq.pop();\n            n--; \n\n            if (vis.find(val * 2) == vis.end())\n            {\n                pq.push(val * 2);\n                vis.insert(val * 2);\n            }\n            if (vis.find(val * 3) == vis.end())\n            {\n                pq.push(val * 3);\n                vis.insert(val * 3);\n            }\n            if (vis.find(val * 5) == vis.end())\n            {\n                pq.push(val * 5);\n                vis.insert(val * 5);\n            }\n        }\n\n        return val; // After n iterations this is the number you get\n    }\n};"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5652764/beats-100-bottom-up-easy-approach-vid-ex-syz1/",
    "content": "Vid Explanation\n\nIntuition\n\n\nUgly numbers are numbers whose prime factors are limited to 2, 3, and 5.\nThe nth ugly number can be obtained by multiplying a previous ugly number by 2, 3, or 5.\nWe can efficiently generate ugly numbers by keeping track of the smallest possible multiplications of existing ugly numbers by 2, 3, and 5.\n\nApproach\n\n\nCreate a dynamic programming array dp to store the ugly numbers. Initialize dp[0] to 1.\nMaintain three pointers p1, p2, and p3 to track the indices of the next ugly number to be multiplied by 2, 3, and 5 respectively.\nIterate through the dp array:\nCalculate the potential next ugly numbers by multiplying dp[p1] by 2, dp[p2] by 3, and dp[p3] by 5.\nFind the minimum of these three values and store it as the next ugly number in dp.\nIncrement the corresponding pointer (p1, p2, or p3) based on which value was chosen.\nReturn the last element of the dp array, which is the nth ugly number.\n\nComplexity\n\nTime complexity:O(n)\n\n\n\nSpace complexity:O(n)\n\n\nCode\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n\n        vector<int> dp(n);\n        dp[0] = 1;\n\n        int p1 = 0;\n        int p2 = 0;\n        int p3 = 0;\n\n        for(int i=1;i<n;i++){\n\n            int twoMul = dp[p1] * 2;\n            int threeMul = dp[p2] * 3;\n            int fiveMul = dp[p3] * 5;\n\n            dp[i] = min(twoMul, min(threeMul,fiveMul ));\n\n            if(dp[i] == twoMul) p1++;\n            if(dp[i] == threeMul) p2++;\n            if(dp[i] ==  fiveMul) p3++;\n            \n        }\n\n        return dp[n-1];\n        \n    }\n};",
    "code_blocks": [
      "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n\n        vector<int> dp(n);\n        dp[0] = 1;\n\n        int p1 = 0;\n        int p2 = 0;\n        int p3 = 0;\n\n        for(int i=1;i<n;i++){\n\n            int twoMul = dp[p1] * 2;\n            int threeMul = dp[p2] * 3;\n            int fiveMul = dp[p3] * 5;\n\n            dp[i] = min(twoMul, min(threeMul,fiveMul ));\n\n            if(dp[i] == twoMul) p1++;\n            if(dp[i] == threeMul) p2++;\n            if(dp[i] ==  fiveMul) p3++;\n            \n        }\n\n        return dp[n-1];\n        \n    }\n};"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/718879/python-on-universal-dp-solution-explaine-t423/",
    "content": "Let us solve this problem for general case: that is not only for 2,3,5 divisors, but for any of them and any number of them. factors = [2,3,5] and  k=3 in our case.\nLet Numbers be an array, where we keep all our ugly numbers. Also, note, that any ugly number is some other ugly number, multiplied by 2, 3 or 5. So, let starts be the indexes of ugly numbers, that when multiplied by 2, 3 or 5 respectively, produces the smallest ugly number that is larger than the current overall maximum ugly number.. Let us do several first steps to understand it better:\n\nstarts = [0,0,0] for numbers 2,3,5, so new_num = min(1*2,1*3,1*5) = 2, and now starts = [1,0,0], Numbers = [1,2].\nstarts = [1,0,0], so new_num = min(2*2,1*3,1*5) = 3, and now starts = [1,1,0], Numbers = [1,2,3].\nstarts = [1,1,0], so new_num = min(2*2,2*3,1*5) = 4, so now starts = [2,1,0], Numbers = [1,2,3,4].\nstarts = [2,1,0], so new_num = min(3*2,2*3,1*5) = 5, so now starts = [2,1,1], Numbers = [1,2,3,4,5].\nstarts = [2,1,1], so new_num = min(3*2,2*3,2*5) = 6, so let us be carefull in this case: we need to increase two numbers from start, because our new number 6 can be divided both by 2 and 3, so now starts = [3,2,1], Numbers = [1,2,3,4,5,6].\nstarts = [3,2,1], so new_num = min(4*2,3*3,2*5) = 8, so now starts = [4,2,1], Numbers = [1,2,3,4,5,6,8]\nstarts = [4,2,1], so new_num = min(5*2,3*3,2*5) = 9, so now starts = [4,3,1], Numbers = [1,2,3,4,5,6,8,9].\nstarts = [4,3,1], so new_num = min(5*2,4*3,2*5) = 10, so we need to update two elements from starts and now starts = [5,3,2], Numbers = [1,2,3,4,5,6,8,9,10]\nstarts = [5,3,2], so new_num = min(6*2,4*3,3*5) = 12, we again need to update two elements from starts, and now starts = [6,4,2], Numbers = [1,2,3,4,5,6,8,9,10,12].\nstarts = [6,4,2], so new_num = min(8*2,5*3,3*5) = 15, we again need to update two elements from starts, and now starts = [6,5,3], Numbers = [1,2,3,4,5,6,8,9,10,12,15].\n\nComplexity: time complexity is O(n) to find ugly number with number n, because on each step we check 3 possible candidates. Space complexity is O(n) as well. Note, that it can be easily generalized for different amount of divisors with time complexity O(nk), where k is total number of divisors.\nclass Solution:\n    def nthUglyNumber(self, n):\n        factors, k = [2,3,5], 3\n        starts, Numbers = [0] * k, [1]\n        for i in range(n-1):\n            candidates = [factors[i]*Numbers[starts[i]] for i in range(k)]\n            new_num = min(candidates)\n            Numbers.append(new_num)\n            starts = [starts[i] + (candidates[i] == new_num) for i in range(k)]\n        return Numbers[-1]\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
    "code_blocks": [
      "class Solution:\n    def nthUglyNumber(self, n):\n        factors, k = [2,3,5], 3\n        starts, Numbers = [0] * k, [1]\n        for i in range(n-1):\n            candidates = [factors[i]*Numbers[starts[i]] for i in range(k)]\n            new_num = min(candidates)\n            Numbers.append(new_num)\n            starts = [starts[i] + (candidates[i] == new_num) for i in range(k)]\n        return Numbers[-1]",
      "#define ll long long int\n    \n    int nthUglyNumber(int n) {\n        set<ll>s;\n        s.insert({1,2,3,5});\n        \n        int count = 0;\n        while(!s.empty()){\n            int x = (int)*(s.begin());   // x = smallest number\n            count ++;\n            \n            if(count == n) return x;\n            \n            s.erase(s.begin());\n            s.insert({(ll)x*2, (ll)x*3, (ll)x*5});\n        }\n        return 69; // a sexy number\n    }",
      "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        nums, idx, factors = [1], [0,0,0], [2, 3, 5]\n        for _ in range(n-1):\n            cans = [x * y for x,y in zip([nums[i] for i in idx], factors)]\n            nums += min(cans),\n            idx = [i + (c == nums[-1]) for i,c in zip(idx, cans)]\n            \n        return nums[-1]"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5652799/python-dynamic-programming-by-khosiyat-irp9/",
    "content": "see the Successfully Accepted Submission\nCode\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        # Initialize the ugly number list with the first ugly number\n        ugly = [1]\n        \n        # Initialize pointers for multiples of 2, 3, and 5\n        i2 = i3 = i5 = 0\n        \n        # Continue generating ugly numbers until we reach the nth one\n        while len(ugly) < n:\n            # Calculate the next candidates for ugly numbers\n            next_ugly_2 = ugly[i2] * 2\n            next_ugly_3 = ugly[i3] * 3\n            next_ugly_5 = ugly[i5] * 5\n            \n            # Choose the smallest candidate\n            next_ugly = min(next_ugly_2, next_ugly_3, next_ugly_5)\n            ugly.append(next_ugly)\n            \n            # Increment the corresponding pointer(s)\n            if next_ugly == next_ugly_2:\n                i2 += 1\n            if next_ugly == next_ugly_3:\n                i3 += 1\n            if next_ugly == next_ugly_5:\n                i5 += 1\n        \n        # Return the nth ugly number\n        return ugly[n-1]\n\nApproach\nInitialization:\n\nStart with the first ugly number, which is 1.\nUse three pointers, i2, i3, and i5, to track the positions for multiples of 2, 3, and 5 respectively.\nThe initial values of these pointers will all be 0, meaning the smallest multiples of 2, 3, and 5 initially are 2*1, 3*1, and 5*1.\n\nGenerate the sequence:\n\nFor each subsequent ugly number, select the smallest value among 2 * ugly[i2], 3 * ugly[i3], and 5 * ugly[i5].\nAppend this smallest value to the list of ugly numbers.\nMove the corresponding pointer (i.e., increment i2, i3, or i5) for the selected minimum value.\nRepeat the process until the nth ugly number is found.\n\nReturn the nth ugly number from the list.\nExplanation\n\nTime Complexity: The loop runs n times, and each step takes constant time, so the time complexity is O(n).\nSpace Complexity: We store n ugly numbers in the list, so the space complexity is O(n).\n\nExample Run\nFor n = 10, the generated sequence is [1, 2, 3, 4, 5, 6, 8, 9, 10, 12], and the 10th ugly number is 12.",
    "code_blocks": [
      "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        # Initialize the ugly number list with the first ugly number\n        ugly = [1]\n        \n        # Initialize pointers for multiples of 2, 3, and 5\n        i2 = i3 = i5 = 0\n        \n        # Continue generating ugly numbers until we reach the nth one\n        while len(ugly) < n:\n            # Calculate the next candidates for ugly numbers\n            next_ugly_2 = ugly[i2] * 2\n            next_ugly_3 = ugly[i3] * 3\n            next_ugly_5 = ugly[i5] * 5\n            \n            # Choose the smallest candidate\n            next_ugly = min(next_ugly_2, next_ugly_3, next_ugly_5)\n            ugly.append(next_ugly)\n            \n            # Increment the corresponding pointer(s)\n            if next_ugly == next_ugly_2:\n                i2 += 1\n            if next_ugly == next_ugly_3:\n                i3 += 1\n            if next_ugly == next_ugly_5:\n                i5 += 1\n        \n        # Return the nth ugly number\n        return ugly[n-1]"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/69364/my-16ms-c-dp-solution-with-short-explana-h56l/",
    "content": "We have an array k of first n ugly number. We only know, at the beginning, the first one, which is 1. Then\nk[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:\nk[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3.\nx here is multiplication.\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        if(n <= 0) return false; // get rid of corner cases \n        if(n == 1) return true; // base case\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\n        vector<int> k(n);\n        k[0] = 1;\n        for(int i  = 1; i < n ; i ++)\n        {\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\n            if(k[i] == k[t2]*2) t2++; \n            if(k[i] == k[t3]*3) t3++;\n            if(k[i] == k[t5]*5) t5++;\n        }\n        return k[n-1];\n    }\n};",
    "code_blocks": [
      "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        if(n <= 0) return false; // get rid of corner cases \n        if(n == 1) return true; // base case\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\n        vector<int> k(n);\n        k[0] = 1;\n        for(int i  = 1; i < n ; i ++)\n        {\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\n            if(k[i] == k[t2]*2) t2++; \n            if(k[i] == k[t3]*3) t3++;\n            if(k[i] == k[t5]*5) t5++;\n        }\n        return k[n-1];\n    }\n};",
      "public int nthUglyNumber(int n) {\n        int p2 = 0, p3 = 0, p5 = 0;\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++){\n            /* \n                2: currentUglyNumber = min(1 * 2, 1 * 3, 1* 5) = 2\n                    produced by p2, so p2++ \n                    dp [1, 2]\n                3: currentUglyNumber = min(2 * 2, 1 * 3, 1 * 5) = 3\n                    produced by p3, so p3++\n                    dp [1, 2, 3]\n                4: currentUglyNumber = min(2 * 2, 2 * 3, 1 * 5) = 4\n                    produced by p2, so p2++\n                    dp [1, 2, 3, 4]\n                5: currentUglyNumber = min(3 * 2, 2 * 3, 1 * 5) = 5\n                    produced by p5, so p5++\n                    dp [1, 2, 3, 4, 5]\n                6: currentUglyNumber = min(3 * 2, 2 * 3, 2 * 5) = 6\n                    produced by p2 AND p3, so p2++ and p3++\n                    dp [1, 2, 3, 4, 5, 6]\n                7: currentUglyNumber = min(4 * 2, 3 * 3, 2 * 5) = 8\n                    produced by p2, so p2++\n                    dp [1, 2, 3, 4, 5, 6, 8]\n                8: currentUglyNumber = min(5 * 2, 3 * 3, 2 * 5) = 9\n                    produced by p3, so p3++\n                    dp [1, 2, 3, 4, 5, 6, 8, 9]\n                9: currentUglyNumber = min(5 * 2, 4 * 3, 2 * 5) = 10\n                    produced by p2 and p5, p2++ and p5++\n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10]\n                10: currentUglyNumber = min(8 * 2, 4 * 3, 3 * 5) = 12\n                    NOTE the 8, that's the value at index 6\n                    produced by p3, p3++\n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\n                11: currentUglyNumber = min(8 * 2, 5 * 3, 3 * 5) = 15\n                    produced by p3 and p5, p3++ and p5++\n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15]\n                12: currentUglyNumber = min(8 * 2, 8 * 3, 4 * 5) = 16\n                    produced by p2, p2++\n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16]\n                13: currentUglyNumber = min(9 * 2, 8 * 3, 4 * 5) = 18\n                    produced by p2, p2++   \n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18]\n                14: currentUglyNumber = min(10 * 2, 8 * 3, 4 * 5) = 20\n                    produced by p2 and p5, p2++ p5++   \n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20]\n                15: currentUglyNumber = min(12 * 2, 8 * 3, 5 * 5) = 24\n                    produced by p2 and p3, p2++ p3++   \n                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]\n                    \n                etc.. \n            */\n            int p2Val = dp[p2] * 2;\n            int p3Val = dp[p3] * 3;\n            int p5Val = dp[p5] * 5;\n            int currentUglyNumber = Math.min(p2Val, Math.min(p3Val, p5Val));\n            /* \n                move the pointer(s) that produced the currentUglyNumber\n                so we don't consider that value again\n            */\n            if (currentUglyNumber == p2Val) p2++;\n            if (currentUglyNumber == p3Val) p3++;\n            if (currentUglyNumber == p5Val) p5++;\n            dp[i] = currentUglyNumber;\n        }\n        return dp[n - 1];\n    }",
      "[1, 2, 4, 6, 8, 10, 12, 16, ... ]\n[1, 3, 6, 9, 12, 15, 18, 24, ...]\n[1, 5, 10, 15, 20, 25, 30, ...]",
      "public int nthUglyNumber(int n) {\n    int[] uglyNumbers = new int[n];\n    uglyNumbers[0] = 1;\n    int index2 = 0, index3 = 0, index5 = 0;\n    \n    for (int i = 1; i < n; i++) {\n        // generate ugly number by multiply all the factors\n        uglyNumbers[i] = Math.min(uglyNumbers[index2] * 2, Math.min(uglyNumbers[index3] * 3, uglyNumbers[index5] * 5));\n        \n        // bump up index for the current minimum ugly number \n        if (uglyNumbers[i] == uglyNumbers[index2] * 2) index2++;\n        if (uglyNumbers[i] == uglyNumbers[index3] * 3) index3++;\n        if (uglyNumbers[i] == uglyNumbers[index5] * 5) index5++;\n    }\n    \n    return uglyNumbers[n - 1];\n}",
      "public int nthUglyNumber(int n) {\n        int[] nums = new int[n + 1];\n        nums[1] = 1;\n        int i2 = 0, i3 = 0, i5 = 0;\n        int u2 = nums[1], u3 = nums[1], u5 = nums[1];\n        for (int i = 1; i <= n; i++) {\n            nums[i] = Math.min(u2, Math.min(u3, u5));\n            if (nums[i] == u2) u2 = nums[++i2] * 2;\n            if (nums[i] == u3) u3 = nums[++i3] * 3;\n            if (nums[i] == u5) u5 = nums[++i5] * 5;\n        }\n        return nums[n];\n    }",
      "class Solution(object):\n    def nthUglyNumber(self, n):\n        &quot;&quot;&quot;\n        :type n: int\n        :rtype: int\n        &quot;&quot;&quot;\n        if n == 1: return 1\n        p1, p2, p3 = 0, 0, 0 #pointers in the following list\n        \n        q = [0] * n\n        q[0] = 1\n        \n        for i in range(1, n):\n            t1, t2, t3 = q[p1] * 2, q[p2] * 3, q[p3] * 5\n            q[i] = min(t1, t2, t3)\n            if q[i] == t1: p1 += 1\n            if q[i] == t2: p2 += 1\n            if q[i] == t3: p3 += 1\n            \n        return q[-1]"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5653571/easy-and-clean-code-c-java-javascript-c-t4bjn/",
    "content": "Intuition\n\nThe problem at hand is to find the n-th \"ugly number.\" An ugly number is defined as a number whose only prime factors are 2, 3, or 5. The idea here is to generate ugly numbers in a sequential manner.\nApproach\n\n\nInitialization:\n•\tA vector t of size n+1 is used to store the first n ugly numbers, with t[1] initialized to 1 (since 1 is considered the first ugly number).\n•\tThree pointers, t2, t3, and t5, are used to keep track of the position in the list for generating the next ugly number by multiplying by 2, 3, and 5, respectively.\nGenerating Ugly Numbers:\n•\tIn each iteration, compute potential next ugly numbers by multiplying the current values pointed to by t2, t3, and t5 with 2, 3, and 5, respectively.\n•\tThe next ugly number t[i] is the minimum of these potential values.\n•\tUpdate the pointers t2, t3, and t5 as needed:\no\tIf t[i] matches the value generated by multiplying t[t2] by 2, increment t2.\no\tIf t[i] matches the value generated by multiplying t[t3] by 3, increment t3.\no\tIf t[i] matches the value generated by multiplying t[t5] by 5, increment t5.\nReturn:\n•\tAfter the loop completes, t[n] will be the nnn-th ugly number.\n\nComplexity\n\nTime complexity:\n\n\n    The time complexity of this approach is O(n).\n\nSpace complexity:\n\n\n    O(n)\nCode\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> t(n + 1); //To handle edge cases\n        t[1] = 1; // First ugly number\n        // Initialize t2, t3 & t5 with 1 to pointing the 1st ugly number\n        int t2 = 1;\n        int t3 = 1;\n        int t5 = 1;\n        for (int i = 2; i <= n; i++) {\n            int second = t[t2] * 2;\n            int third = t[t3] * 3;\n            int fifth = t[t5] * 5;\n            t[i] = min({second, third, fifth});\n            if (t[i] == second) {\n                t2++;\n            }\n            if (t[i] == third) {\n                t3++;\n            }\n            if (t[i] == fifth) {\n                t5++;\n            }\n        }\n        return t[n];\n    }\n};",
    "code_blocks": [
      "The time complexity of this approach is O(n).",
      "O(n)",
      "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> t(n + 1); //To handle edge cases\n        t[1] = 1; // First ugly number\n        // Initialize t2, t3 & t5 with 1 to pointing the 1st ugly number\n        int t2 = 1;\n        int t3 = 1;\n        int t5 = 1;\n        for (int i = 2; i <= n; i++) {\n            int second = t[t2] * 2;\n            int third = t[t3] * 3;\n            int fifth = t[t5] * 5;\n            t[i] = min({second, third, fifth});\n            if (t[i] == second) {\n                t2++;\n            }\n            if (t[i] == third) {\n                t3++;\n            }\n            if (t[i] == fifth) {\n                t5++;\n            }\n        }\n        return t[n];\n    }\n};"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/69368/elegant-c-solution-on-space-time-with-de-6b3b/",
    "content": "struct Solution {\n    int nthUglyNumber(int n) {\n        vector <int> results (1,1);\n        int i = 0, j = 0, k = 0;\n        while (results.size() < n)\n        {\n            results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\n            if (results.back() == results[i] * 2) ++i;\n            if (results.back() == results[j] * 3) ++j;\n            if (results.back() == results[k] * 5) ++k;\n        }\n        return results.back();\n    }\n};\nExplanation:\nThe key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5\ne.g.\n1 2 3 4 5 6 8 9 10 12 15..\nwhat is next?\nit must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.\nHow do we determine x, y, z then?\napparently, you can just traverse the sequence generated by far from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.\nk, now you have 1,2,3,4,....,15, 16,\nThen what is next?\nYou wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to\ntraverse the sequence generated by far again?\nNO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.\nThen you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;\nAnd you also know, the next x will be 10 since new_x = 9 was used this time.\nBut what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.\nBased on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.",
    "code_blocks": [
      "struct Solution {\n    int nthUglyNumber(int n) {\n        vector <int> results (1,1);\n        int i = 0, j = 0, k = 0;\n        while (results.size() < n)\n        {\n            results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\n            if (results.back() == results[i] * 2) ++i;\n            if (results.back() == results[j] * 3) ++j;\n            if (results.back() == results[k] * 5) ++k;\n        }\n        return results.back();\n    }\n};",
      "if(n <= 0 || n > 1691) return 0;",
      "# no.1690\n2125764000: 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5\n# no.1691\n2123366400: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 5 5",
      "Use Static... \n int nthUglyNumber(int n) {\n        static vector <int> results (1,1);\n        static int i = 0, j = 0, k = 0;\n        while (results.size() < n)\n        {\n            results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\n            if (results.back() == results[i] * 2) ++i;\n            if (results.back() == results[j] * 3) ++j;\n            if (results.back() == results[k] * 5) ++k;\n        }\n        return results[n-1];\n    }"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5652689/easy-heap-dp-solution-beats-100-by-sachi-lw6t/",
    "content": "Heap Method\nPythonC++Javaclass Solution(object):\n    def nthUglyNumber(self, n):\n        primes = [2,3,5]\n        uglyHeap = [1]\n        visited = set()\n        visited.add(1)\n        for _ in range(n):\n            curr = heappop(uglyHeap)\n            for prime in primes:\n                new_ugly = curr * prime\n                if new_ugly not in visited:\n                    heappush(uglyHeap, new_ugly)\n                    visited.add(new_ugly)\n        return curr\nDP\nPythonC++Javaclass Solution(object):\n    def nthUglyNumber(self, n):\n        primes = [2, 3, 5]\n        next_ugly = [2, 3, 5]\n        increase = [1, 1, 1]\n        arr = [1]\n        \n        for _ in range(1, n):\n            smallest = min(next_ugly)\n            arr.append(smallest)\n            \n            for i in range(3):\n                if next_ugly[i] == smallest:\n                    increase[i] += 1\n                    next_ugly[i] = primes[i] * arr[increase[i] - 1]\n        \n        return arr[-1]",
    "code_blocks": [
      "class Solution(object):\n    def nthUglyNumber(self, n):\n        primes = [2,3,5]\n        uglyHeap = [1]\n        visited = set()\n        visited.add(1)\n        for _ in range(n):\n            curr = heappop(uglyHeap)\n            for prime in primes:\n                new_ugly = curr * prime\n                if new_ugly not in visited:\n                    heappush(uglyHeap, new_ugly)\n                    visited.add(new_ugly)\n        return curr",
      "class Solution(object):\n    def nthUglyNumber(self, n):\n        primes = [2, 3, 5]\n        next_ugly = [2, 3, 5]\n        increase = [1, 1, 1]\n        arr = [1]\n        \n        for _ in range(1, n):\n            smallest = min(next_ugly)\n            arr.append(smallest)\n            \n            for i in range(3):\n                if next_ugly[i] == smallest:\n                    increase[i] += 1\n                    next_ugly[i] = primes[i] * arr[increase[i] - 1]\n        \n        return arr[-1]",
      "}\n    return dp[n-1];\n    \n}"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/3235848/best-c-3-solution-dp-tabulation-hash-tab-cm7k/",
    "content": "Intuition\n\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\n\nSolved using Math.\nSolved using Hash Table.\nSolved using Dynamic Programming (Tabulation).\n\nApproach\n\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime complexity is given in code comment.\n\nSpace complexity:\n\n\nSpace complexity is given in code comment.\nCode\n/*\n\n    Time Complexity : O(K) where K is the nth ugly number. Beacuse we are traversing the loop K times so, the\n    time complexity is O(K).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Math.\n\n    Note : This approach will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    int keepsOndividingUntilPossible(int dividend, int divisor){\n        while(dividend % divisor == 0){\n            dividend /= divisor;\n        }\n        return dividend;\n    }\npublic:\n    int nthUglyNumber(int n) {\n        int i=0, count=0;\n        while(count < n){\n            int isUgly = i+1;\n            for(auto factor : {2,3,5}){\n                isUgly = keepsOndividingUntilPossible(isUgly, factor);\n            }\n            if(isUgly == 1){\n                count++;\n            }\n            i++;\n        }\n        return i;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(NlogN), The time complexity of the code is O(NlogN) since we are doing 3 insertion\n    operation in Hash Table(set) for each iteration in loop N times and insertion operation in Hash Table(set) \n    takes logN time. Where N is the given number n.\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Hash Table.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        set<long> set;\n        long nthNumber = 1;\n        set.insert(nthNumber);\n        for(int i=0; i<n; i++){\n            nthNumber = *set.begin();\n            set.erase(nthNumber);\n            set.insert(nthNumber*2);\n            set.insert(nthNumber*3);\n            set.insert(nthNumber*5);\n        }\n        return nthNumber;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), Here loop creates the time Complexity. Where N is the given number n.\n\n    Space Complexity : O(N), Array(dp) space.\n\n    Solved using Dynamic Programming (Tabulation).\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0]=1;\n        int x=0, y=0, z=0;\n        for(int i=1; i<n; i++){\n            dp[i] = min(dp[x]*2, min(dp[y]*3, dp[z]*5));\n            if(dp[i] == 2*dp[x]) x++;\n            if(dp[i] == 3*dp[y]) y++;\n            if(dp[i] == 5*dp[z]) z++;\n        }\n        return dp[n-1];\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.",
    "code_blocks": [
      "/*\n\n    Time Complexity : O(K) where K is the nth ugly number. Beacuse we are traversing the loop K times so, the\n    time complexity is O(K).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Math.\n\n    Note : This approach will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    int keepsOndividingUntilPossible(int dividend, int divisor){\n        while(dividend % divisor == 0){\n            dividend /= divisor;\n        }\n        return dividend;\n    }\npublic:\n    int nthUglyNumber(int n) {\n        int i=0, count=0;\n        while(count < n){\n            int isUgly = i+1;\n            for(auto factor : {2,3,5}){\n                isUgly = keepsOndividingUntilPossible(isUgly, factor);\n            }\n            if(isUgly == 1){\n                count++;\n            }\n            i++;\n        }\n        return i;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(NlogN), The time complexity of the code is O(NlogN) since we are doing 3 insertion\n    operation in Hash Table(set) for each iteration in loop N times and insertion operation in Hash Table(set) \n    takes logN time. Where N is the given number n.\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Hash Table.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        set<long> set;\n        long nthNumber = 1;\n        set.insert(nthNumber);\n        for(int i=0; i<n; i++){\n            nthNumber = *set.begin();\n            set.erase(nthNumber);\n            set.insert(nthNumber*2);\n            set.insert(nthNumber*3);\n            set.insert(nthNumber*5);\n        }\n        return nthNumber;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), Here loop creates the time Complexity. Where N is the given number n.\n\n    Space Complexity : O(N), Array(dp) space.\n\n    Solved using Dynamic Programming (Tabulation).\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0]=1;\n        int x=0, y=0, z=0;\n        for(int i=1; i<n; i++){\n            dp[i] = min(dp[x]*2, min(dp[y]*3, dp[z]*5));\n            if(dp[i] == 2*dp[x]) x++;\n            if(dp[i] == 3*dp[y]) y++;\n            if(dp[i] == 5*dp[z]) z++;\n        }\n        return dp[n-1];\n    }\n};"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/69384/my-expressive-python-solution-by-alexef-a0is/",
    "content": "def nthUglyNumber(self, n):\n    ugly = [1]\n    i2, i3, i5 = 0, 0, 0\n    while n > 1:\n        u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\n        umin = min((u2, u3, u5))\n        if umin == u2:\n            i2 += 1\n        if umin == u3:\n            i3 += 1\n        if umin == u5:\n            i5 += 1\n        ugly.append(umin)\n        n -= 1\n    return ugly[-1]",
    "code_blocks": [
      "def nthUglyNumber(self, n):\n    ugly = [1]\n    i2, i3, i5 = 0, 0, 0\n    while n > 1:\n        u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\n        umin = min((u2, u3, u5))\n        if umin == u2:\n            i2 += 1\n        if umin == u3:\n            i3 += 1\n        if umin == u5:\n            i5 += 1\n        ugly.append(umin)\n        n -= 1\n    return ugly[-1]"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/6178266/java-solution-treeset-by-shyam_jee-cmyo/",
    "content": "Complexity\n\nTime complexity:O(N∗Log(N))\n\n\n\nSpace complexity:O(N)\n\n\nCode\nJavaclass Solution {\n    public int nthUglyNumber(int n) {\n        TreeSet<Long> uglySet=new TreeSet<>();\n        long curr=1;\n        uglySet.add(1l);\n        while(n-->0)\n        {\n            curr=uglySet.removeFirst();\n            uglySet.add(curr*2l);\n            uglySet.add(curr*3l);\n            uglySet.add(curr*5l);\n        }\n        return (int)curr;\n    }\n}",
    "code_blocks": [
      "class Solution {\n    public int nthUglyNumber(int n) {\n        TreeSet<Long> uglySet=new TreeSet<>();\n        long curr=1;\n        uglySet.add(1l);\n        while(n-->0)\n        {\n            curr=uglySet.removeFirst();\n            uglySet.add(curr*2l);\n            uglySet.add(curr*3l);\n            uglySet.add(curr*5l);\n        }\n        return (int)curr;\n    }\n}"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/69362/on-java-solution-by-syftalent-8clu/",
    "content": "The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/\nThe ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, …\nbecause every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:\n(1) 1×2, 2×2, 3×2, 4×2, 5×2, …\n(2) 1×3, 2×3, 3×3, 4×3, 5×3, …\n(3) 1×5, 2×5, 3×5, 4×5, 5×5, …\nWe can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, …) multiply 2, 3, 5.\nThen we use similar merge method as merge sort, to get every ugly number from the three subsequence.\nEvery step we choose the smallest one, and move one step after,including nums with same value.\nThanks for this author about this brilliant idea. Here is my java solution\npublic class Solution {\n    public int nthUglyNumber(int n) {\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        int index2 = 0, index3 = 0, index5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n        for(int i=1;i<n;i++){\n            int min = Math.min(Math.min(factor2,factor3),factor5);\n            ugly[i] = min;\n            if(factor2 == min)\n                factor2 = 2*ugly[++index2];\n            if(factor3 == min)\n                factor3 = 3*ugly[++index3];\n            if(factor5 == min)\n                factor5 = 5*ugly[++index5];\n        }\n        return ugly[n-1];\n    }\n}",
    "code_blocks": [
      "public class Solution {\n    public int nthUglyNumber(int n) {\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        int index2 = 0, index3 = 0, index5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n        for(int i=1;i<n;i++){\n            int min = Math.min(Math.min(factor2,factor3),factor5);\n            ugly[i] = min;\n            if(factor2 == min)\n                factor2 = 2*ugly[++index2];\n            if(factor3 == min)\n                factor3 = 3*ugly[++index3];\n            if(factor5 == min)\n                factor5 = 5*ugly[++index5];\n        }\n        return ugly[n-1];\n    }\n}",
      "public int nthUglyNumber(int n) {\n        int[] nums = new int[n];\n        int index2 = 0, index3 = 0, index5 = 0;\n        nums[0] = 1;\n        for(int i = 1; i < nums.length; i++){\n            nums[i] = Math.min(nums[index2] * 2, Math.min(nums[index3] * 3, nums[index5] * 5));\n            if(nums[i] == nums[index2] * 2)\n                index2++;\n            if(nums[i] == nums[index3] * 3)\n                index3++;\n            if(nums[i] == nums[index5] * 5)\n                index5++;\n        }\n        return nums[n - 1];\n    }",
      "public int nthUglyNumber(int n) {\n    int i = 0, j = 0, k = 0, p = 1;\n    \n    int[] dp = new int[n];\n    dp[0] = 1;\n    \n    while (p < n) {\n        dp[p] = Math.min(dp[i] * 2, Math.min(dp[j] * 3, dp[k] * 5));\n        if (dp[p] == dp[i] * 2) i++;\n        if (dp[p] == dp[j] * 3) j++;\n        if (dp[p] == dp[k] * 5) k++;\n        p++;\n    }\n    \n    return dp[n - 1];\n  }",
      "public int LC264nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    int index2 = 0, index3 = 0, index5 = 0;\n    int Sequence2 = 1, Sequence3 = 1, Sequence5 = 1;\n    for(int i=0;i<n;i++){\n        ugly[i] = Math.min(Math.min(Sequence2,Sequence3),Sequence5);//min of the 3 sequences is the ith UglyNumber \n        if(Sequence2 == ugly[i]) Sequence2 = 2*ugly[index2++];//the ith UglyNumber is in factor2 sequence, then update sequence2\n        if(Sequence3 == ugly[i]) Sequence3 = 3*ugly[index3++];//the ith UglyNumber is in factor3 sequence, then update sequence3\n        if(Sequence5 == ugly[i]) Sequence5 = 5*ugly[index5++];//the ith UglyNumber is in factor5 sequence, then update sequence5\n    }\n    return ugly[n-1];//return the nth UglyNumber\n}",
      "(1) 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2, ... (Notice that there is no 7 because 7 does not belong to ugly number factor)\n(2) 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3, ...\n(3) 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5, 9×5, ...",
      "public class Solution {\n    static int[] ugly = new int[1691];\n    static {\n        ugly[0] = 1;\n        int index2 = 0, index3 = 0, index5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n        for (int i = 1; i < ugly.length; i++) {\n            int min = Math.min(Math.min(factor2, factor3), factor5);\n            ugly[i] = min;\n            if (factor2 == min)\n                factor2 = 2 * ugly[++index2];\n            if (factor3 == min)\n                factor3 = 3 * ugly[++index3];\n            if (factor5 == min)\n                factor5 = 5 * ugly[++index5];\n        }\n    }\n\n    public int nthUglyNumber(int n) {\n        return ugly[n - 1];\n    }\n}"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/6151666/java-fastest-solution-by-shreyagarg63-1ywq/",
    "content": "Remainder :-\n\nNo number is ugly  ;)\n\nCode\nJavaclass Solution {\n    public int nthUglyNumber(int n) {\n        if(n == 1) return 1;\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n\n        int next2 = 2, next3 = 3, next5 = 5;\n        int i2 = 0, i3 = 0, i5 = 0;\n\n        for(int i = 1; i<n; i++){\n            int num = Math.min(next2, Math.min(next3, next5));\n            ugly[i] = num;\n\n            if(num == next2){\n                i2++;\n                next2 = ugly[i2]*2;\n            }\n            if(num == next3){\n                i3++;\n                next3 = ugly[i3]*3;\n            }\n            if(num == next5){\n                i5++;\n                next5 = ugly[i5]*5;\n            }\n        }\n\n        return ugly[n-1];\n    }\n}",
    "code_blocks": [
      "class Solution {\n    public int nthUglyNumber(int n) {\n        if(n == 1) return 1;\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n\n        int next2 = 2, next3 = 3, next5 = 5;\n        int i2 = 0, i3 = 0, i5 = 0;\n\n        for(int i = 1; i<n; i++){\n            int num = Math.min(next2, Math.min(next3, next5));\n            ugly[i] = num;\n\n            if(num == next2){\n                i2++;\n                next2 = ugly[i2]*2;\n            }\n            if(num == next3){\n                i3++;\n                next3 = ugly[i3]*3;\n            }\n            if(num == next5){\n                i5++;\n                next5 = ugly[i5]*5;\n            }\n        }\n\n        return ugly[n-1];\n    }\n}"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5649364/ugly-number-ii-by-leetcode-wwhl/",
    "content": "Solution\n\nOverview\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. This means that for a number to be classified as ugly, it can only be divided by these primes without leaving a remainder.\nIn Example 2, we observe that the number 1 is considered an ugly number, even though it lacks any prime factors of 2, 3, or 5. This might seem confusing initially, but the explanation clarifies that \"1 has no prime factors; therefore, all of its prime factors are limited to 2, 3, and 5.\" This statement can be somewhat misleading if not properly understood. It implies that since 1 has no prime factors, it doesn't violate the rule that ugly numbers can only have prime factors of 2, 3, or 5. In essence, 1 automatically meets the condition, as there are no prime factors to contradict the rule.\n\nIn short 1 is an ugly number because it can be expressed as 20×30×50\n\nApproach 1: Using Set\nIntuition\nWe begin with a brute force approach where the goal is to count ugly numbers one by one until we reach the nth ugly number. We can create a helper function that checks if a number is ugly by repeatedly dividing it by 2, 3, and 5 until it's no longer divisible by these primes. If the result is 1, the number is ugly. We then iterate through integers applying this check, and count the ugly numbers we encounter. While this method works, it’s inefficient as it checks every number sequentially, including those clearly not ugly (e.g., numbers divisible by other primes). This results in high time complexity, making it unsuitable for large values of n.\nTo improve upon the brute force method, we can leverage a key property of ugly numbers: if a number is ugly, multiplying it by 2, 3, or 5 also yields an ugly number. This insight allows us to generate ugly numbers systematically rather than checking each number individually.\nWe start with the first ugly number, which is 1. From there, we generate the next candidates by multiplying 1 by 2, 3, and 5. These candidates represent the next potential ugly numbers. To ensure we always process the smallest ugly numbers first (necessary to find the nth one), we use a set that keeps elements in sorted order and removes duplicates. We continue this process until we reach the nth ugly number.\nThis approach is more efficient as it avoids unnecessary checks and focuses solely on generating and managing ugly numbers. However, it requires maintaining a set, which can grow large and impact memory usage.\nAlgorithm\n\n\nInitialize a set named uglyNumbersSet to store potential ugly numbers.\n\n\nInsert the first ugly number, 1, into the uglyNumbersSet.\n\n\nInitialize a variable currentUgly to store the current smallest ugly number.\n\n\nLoop n times to find the nth ugly number:\n\nIn each iteration:\n\n\nSet currentUgly to the smallest number in the uglyNumbersSet by accessing the first element.\n\n\nRemove this smallest number from the uglyNumbersSet using erase.\n\n\nInsert the next potential ugly numbers by multiplying currentUgly by 2, 3, and 5:\n\nInsert currentUgly * 2 into the uglyNumbersSet.\nInsert currentUgly * 3 into the uglyNumbersSet.\nInsert currentUgly * 5 into the uglyNumbersSet.\n\n\n\n\n\n\n\nAfter the loop completes, currentUgly will hold the nth ugly number.\n\n\nReturn currentUgly as the result, casting it to int.\n\n\nImplementation\n\nComplexity Analysis\nLet n be the given index value of the ugly number and m be the size of set.\n\n\nTime complexity: O(nlogm)\nEach insertion and removal operation in the set takes logarithmic time.\n\nIn Python, the min function has a time complexity of O(n) due to the need to scan through all elements of the set to find the minimum. Since this function is called once per iteration of the loop and there are n iterations, the overall time complexity is O(n×m).\n\n\n\nSpace complexity: O(m)\nThe space required depends on the number of unique ugly numbers stored in the set.\n\n\n\nApproach 2: Min-Heap/Priority Queue\nIntuition\nTo further streamline the process, we use a priority queue (min-heap) to efficiently manage and retrieve the smallest ugly number. We start with 1 as our base ugly number and insert it into the min-heap. The priority queue keeps the smallest element at the top, so we can easily access and remove it to get the next ugly number.\nAfter popping the smallest ugly number, we generate new ugly numbers by multiplying them by 2, 3, and 5. These new numbers are then pushed back into the queue. To avoid duplicates, we use a set to track numbers that have already been added, ensuring each ugly number is processed only once.\nAlgorithm\n\nCreate a min-heap (minHeap) to store ugly numbers and a set (seenNumbers) to track numbers already processed.\nPush the first ugly number (1) into the heap and insert it into the set.\nFor n iterations:\n\nPop the smallest ugly number (currentUgly) from the heap.\nGenerate the next ugly numbers by multiplying currentUgly with 2, 3, and 5.\nIf a generated ugly number is not in the set, push it into the heap and add it to the set.\n\n\nAfter n iterations, the last popped number from the heap is the nth ugly number.\nReturn the nth ugly number.\n\nImplementation\n\nComplexity Analysis\nLet n be the given index value of the ugly number and m be the size of set.\n\n\nTime complexity: O(nlogm)\nThe operations on the priority queue (push and pop) take logarithmic time, and there are m such operations.\n\n\nSpace complexity: O(m)\nThe space is used by the heap and the set, which store up to m elements as it depends on the number of unique ugly numbers stored in the set.\n\n\n\nApproach 3: Dynamic Programming (DP)\nIntuition\nThe dynamic programming (DP) approach to finding ugly numbers is based on an idea: every ugly number, except for 1, is generated by multiplying a smaller ugly number by either 2, 3, or 5. This insight allows us to systematically generate ugly numbers in order.\nWe start with 1, the smallest ugly number. To find the next ugly number, we have three options: 1×2, 1×3, and 1×5. The smallest of these, 1×2=2, becomes our second ugly number. For the third ugly number, we again have three choices: the next multiple of 2 (2×2=4), and the unused multiples of 3 and 5 from before (1×3=3 and 1×5=5). We select the smallest of these (which is 3) and continue this process.\nThis approach naturally leads to using three pointers, one each for multiplying by 2, 3, and 5. These pointers track which ugly number should be multiplied by 2, 3, and 5 next. Each time, we choose the smallest of these three possible next ugly numbers, add it to our list, and move the pointer that produced this number.\nThe efficiency and cleverness of this method lie in its simplicity. We build our list of ugly numbers using the same list we are creating. This self-referencing nature characterizes it as dynamic programming. By maintaining the list in order and using pointers, we avoid the need for sorting or removing duplicates, making the algorithm both fast (O(n)) and memory-efficient.\nNow, let's think about why this method works for all ugly numbers:\nWe always start by choosing the smallest number available and manage the process of multiplying by 2, 3, and 5 separately. This approach ensures that no ugly numbers are missed. Specifically, any ugly number must be derived from a previously found smaller ugly number, multiplied by 2, 3, or 5. By maintaining pointers to track these multiplications, we ensure that every number in our list is properly considered for these multiplications.\nBy always selecting the smallest number first from the available multiplications, we prevent the introduction of larger numbers before smaller ones. This strategy eliminates the possibility of missing any ugly numbers, ensuring a consistent and complete generation of ugly numbers.\n\nFor A Formal Proof Click Here:\nProof:\n\n\nBase Case:\n\nWe start with 1, which is an ugly number because it can be expressed as 20×30×50. This is our starting point and is correctly included in the list.\n\n\n\nInductive Hypothesis:\n\nAssume that after generating k ugly numbers, denoted as U1​,U2​,…,Uk​, our list contains all ugly numbers up to the k-th position in ascending order.\n\n\n\nInductive Step:\n\n\nGoal: Show that the algorithm correctly generates the (k+1)-th ugly number.\n\n\nGiven our current list U1​,U2​,…,Uk​, we consider the next possible ugly numbers by multiplying each number in the list by 2, 3, and 5. These potential numbers are Ui​×2, Ui​×3, and Ui​×5, where Ui​ is the smallest number in the list at that step.\n\n\nWe always select the smallest number from these candidates and add it to our list. Let’s denote this smallest number as N. By design, N is the next smallest ugly number that hasn't been added to the list yet.\n\n\nExhaustiveness:\n\nWe ensure that every ugly number is generated by considering all possible multiplications of the smallest numbers. This way, we don't miss any possible ugly number.\n\n\n\nNon-Redundancy:\n\nBy selecting the smallest number each time, we avoid adding duplicate numbers. This ensures that each number added to the list is unique and correctly ordered.\n\n\n\nCompleteness:\n\nEvery ugly number must be derived from previously generated ugly numbers through multiplication by 2, 3, or 5. Our method covers all such possible combinations, so it will eventually generate every ugly number.\n\n\n\n\n\nTermination:\n\nThe algorithm stops once we have generated the desired number of ugly numbers. Since we are systematically adding the smallest possible ugly number at each step, our list will be complete and correctly ordered.\n\n\n\nConclusion:\nBy using induction, we see that starting from the base case of 1, and ensuring each subsequent number is the smallest possible ugly number, we guarantee that our algorithm will generate all ugly numbers in ascending order. This method is both correct and complete, as it ensures that no ugly numbers are missed or duplicated.\n\nAlgorithm\n\nInitialize a vector uglyNumbers of size n to store the ugly numbers, with the first ugly number set to 1.\nSet up three pointers (indexMultipleOf2, indexMultipleOf3, indexMultipleOf5) to track the next multiples of 2, 3, and 5, respectively.\nAssign initial values to nextMultipleOf2, nextMultipleOf3, and nextMultipleOf5 (i.e., 2, 3, and 5).\nFor i from 1 to n-1:\n\nDetermine the next ugly number by taking the minimum of nextMultipleOf2, nextMultipleOf3, and nextMultipleOf5.\nStore this value in uglyNumbers[i].\nUpdate the corresponding pointer and multiple:\n\nIf the next ugly number equals nextMultipleOf2, increment indexMultipleOf2 and update nextMultipleOf2.\nIf the next ugly number equals nextMultipleOf3, increment indexMultipleOf3 and update nextMultipleOf3.\nIf the next ugly number equals nextMultipleOf5, increment indexMultipleOf5 and update nextMultipleOf5.\n\n\n\n\nAfter completing the loop, return the last element in uglyNumbers, which is the nth ugly number.\n\nThe algorithm is visualized below:\n1 / 11\nImplementation\n\nComplexity Analysis\nLet n be the given index value of the ugly number.\n\n\nTime complexity: O(n)\nThis approach is linear because we generate each ugly number directly using the three pointers.\n\n\nSpace complexity: O(n)\nWe need space to store the first n ugly numbers.",
    "code_blocks": [
      "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugos = [1] * n\n        idx = {2: 0, 3: 0, 5: 0}\n        for i in range(1, n):\n            ugos[i] = min(k * ugos[idx[k]] for k in [2, 3, 5])\n            for k in [2, 3, 5]:\n                idx[k] += (k * ugos[idx[k]] == ugos[i])\n\n        return ugos[-1]",
      "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        # Initialize the ugly number list with the first ugly number\n        ugly = [1]\n        \n        # Initialize pointers for multiples of 2, 3, and 5\n        i2 = i3 = i5 = 0\n        \n        # Continue generating ugly numbers until we reach the nth one\n        while len(ugly) < n:\n            # Calculate the next candidates for ugly numbers\n            next_ugly_2 = ugly[i2] * 2\n            next_ugly_3 = ugly[i3] * 3\n            next_ugly_5 = ugly[i5] * 5\n            \n            # Choose the smallest candidate\n            next_ugly = min(next_ugly_2, next_ugly_3, next_ugly_5)\n            ugly.append(next_ugly)\n            \n            # Increment the corresponding pointer(s)\n            if next_ugly == next_ugly_2:\n                i2 += 1\n            if next_ugly == next_ugly_3:\n                i3 += 1\n            if next_ugly == next_ugly_5:\n                i5 += 1\n        \n        # Return the nth ugly number\n        return ugly[n-1]"
    ]
  },
  {
    "url": "https://leetcode.com/problems/ugly-number-ii/solutions/5652702/daily-question-18-aug-here-is-simple-n-e-ruft/",
    "content": "Intuition\n\nHere’s a short and simple explanation of the code:\n\n\nTrack Ugly Numbers: The code finds the nth ugly number (a number whose prime factors are only 2, 3, or 5).\n\n\nPointers: It uses three pointers (t2, t3, t5) to track multiples of 2, 3, and 5.\n\n\nGenerate Ugly Numbers: For each position in the array, calculate the next ugly number as the smallest value among the current multiples of 2, 3, and 5.\n\n\nUpdate Pointers: When a multiple is used, move the respective pointer forward.\n\n\nReturn the nth Ugly Number: The nth ugly number is the last element in the array.\n\n\nApproach\n\n\n\nBase Cases:\n\nReturn 0 if n <= 0 (invalid input).\nReturn 1 if n == 1 (first ugly number is 1).\n\n\n\nInitialize Pointers:\n\nt2, t3, t5 track indices for multiples of 2, 3, and 5.\nArray k stores the sequence of ugly numbers.\n\n\n\nIterate to Find Ugly Numbers:\n\nFor each index i, find the next ugly number as the minimum of:\n\nk[t2] * 2, k[t3] * 3, and k[t5] * 5.\n\n\nIncrement the respective pointer (t2, t3, or t5) if its multiple was chosen.\n\n\n\nReturn the Result:\n\nThe nth ugly number is at k[n-1].\n\n\n\nComplexity\n\nTime complexity:O(n)\n\n\n\nSpace complexity:O(n)\n\nCode\nJavaPython3class Solution {\n    public int nthUglyNumber(int n) {\n        if (n <= 0) return 0; \n        if (n == 1) return 1; \n        \n        int t2 = 0, t3 = 0, t5 = 0; \n        int[] k = new int[n];\n        k[0] = 1;\n        \n        for (int i = 1; i < n; i++) {\n            k[i] = Math.min(k[t2] * 2, Math.min(k[t3] * 3, k[t5] * 5));\n            \n            if (k[i] == k[t2] * 2) t2++;\n            if (k[i] == k[t3] * 3) t3++;\n            if (k[i] == k[t5] * 5) t5++;\n        }\n        \n        return k[n - 1];\n    }\n}\nplz upvote, if you like the explanation",
    "code_blocks": [
      "class Solution {\n    public int nthUglyNumber(int n) {\n        if (n <= 0) return 0; \n        if (n == 1) return 1; \n        \n        int t2 = 0, t3 = 0, t5 = 0; \n        int[] k = new int[n];\n        k[0] = 1;\n        \n        for (int i = 1; i < n; i++) {\n            k[i] = Math.min(k[t2] * 2, Math.min(k[t3] * 3, k[t5] * 5));\n            \n            if (k[i] == k[t2] * 2) t2++;\n            if (k[i] == k[t3] * 3) t3++;\n            if (k[i] == k[t5] * 5) t5++;\n        }\n        \n        return k[n - 1];\n    }\n}"
    ]
  }
]